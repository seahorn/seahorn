#pragma once
#include "seahorn/config.h"

#include "seahorn/Expr/Expr.hh"
#include "seahorn/Expr/Smt/EZ3.hh"
#include "seahorn/Analysis/CutPointGraph.hh"
#include "seahorn/LegacyOperationalSemantics.hh"
#include "boost/logic/tribool.hpp"

namespace llvm {
class TargetLibraryInfo;
class CallGraph;
class DataLayout;
class raw_ostream;
}
namespace sea_dsa {
class AllocWrapInfo;
}

#ifndef HAVE_CLAM
/* Dummy class for PathBmcEngine */
class PathBmcEngine {
  LegacyOperationalSemantics& m_sem;
  SmallVector<const CutPoint *, 8> m_cps;
  SmallVector<const CpEdge *, 8> m_cp_edges;
  std::vector<SymStore> m_states;
  ExprVector m_side;
  ZModel<EZ3> m_model;
public:
  
  PathBmcEngine(LegacyOperationalSemantics &sem, EZ3 &zctx,
		const llvm::DataLayout &dl,
		const llvm::TargetLibraryInfo &tli,
		llvm::CallGraph &cg,
		sea_dsa::AllocWrapInfo &awi)
    : m_sem(sem), m_model(zctx) {}
  
  virtual ~PathBmcEngine() {}

  void addCutPoint(const CutPoint& cp) {}

  void encode() {}
  
  boost::tribool solve() {
    llvm::errs() << "Warning: path bmc engine only available if Clam is available\n";
    return boost:indeterminate;
  }
  
  PathBmcTrace getTrace() { return PathBmcTrace(*this, m_model);}
      
  raw_ostream &toSmtLib(raw_ostream &out) { return out;}

  boost::tribool result() { return boost::indeterminate;}
  
  LegacyOperationalSemantics &sem() { return m_sem;}

  const SmallVector<const CutPoint *, 8> &getCps() const { return m_cps;}
  
  const SmallVector<const CpEdge *, 8> &getEdges() const { return m_cp_edges;}
  
  std::vector<SymStore> &getStates() { return m_states;}

  Expr getSymbReg(const llvm::Value &v) { return Expr(); }

  const ExprVector &getPreciseEncoding() const { return m_side;}
};  
#else
#include "seahorn/LiveSymbols.hh"
#include <queue>
#include <unordered_set>

namespace clam {
class IntraClam;
class HeapAbstraction;
} // namespace clam

/*
  Instead of building a monolithic precise encoding of the program and
  check its satisfiability, this BMC engine enumerates symbolically
  all paths. This enumeration continues until a path is satisfiable or
  no more paths exist.
 */
namespace seahorn {

class PathBmcTrace;
class PathBmcEngine {
public:
  
  PathBmcEngine(LegacyOperationalSemantics &sem, EZ3 &zctx,
		const llvm::DataLayout &dl,
		const llvm::TargetLibraryInfo &tli,
		llvm::CallGraph &cg,
		sea_dsa::AllocWrapInfo &awi);
  
  virtual ~PathBmcEngine();

  void addCutPoint(const CutPoint& cp);

  /// Construct the precise (monolithic) encoding
  void encode();
  
  /// Enumerate paths until a path is satisfiable or there is no
  /// more paths.
  boost::tribool solve();

  /// Returns the BMC trace (if available)
  PathBmcTrace getTrace();

  /// Output the precise encoding generated by the encode method in
  /// SMT-LIB2 format
  raw_ostream &toSmtLib(raw_ostream &out);

  /// returns the latest result from solve()
  boost::tribool result() { return m_result; }
  
  /// return the operational semantics
  LegacyOperationalSemantics &sem() {
    return static_cast<LegacyOperationalSemantics &>(m_sem);
  }

  /// get cut-point trace
  const SmallVector<const CutPoint *, 8> &getCps() const { return m_cps; }

  /// get edges from the cut-point trace
  const SmallVector<const CpEdge *, 8> &getEdges() const { return m_edges; }

  /// get symbolic states corresponding to the cutpoint trace
  std::vector<SymStore> &getStates() { return m_states; }

  Expr getSymbReg(const llvm::Value &v) {
    Expr reg;
    if (m_semCtx) {
      return m_sem.getSymbReg(v, *m_semCtx);
    }
    return reg;
  }

  const ExprVector &getPreciseEncoding() const { return m_precise_side; }
  
private:

  /// symbolic operational semantics
  OperationalSemantics &m_sem;
  /// context for OperationalSemantics
  OpSemContextPtr m_semCtx;
  /// cut-point trace
  SmallVector<const CutPoint *, 8> m_cps;
  /// symbolic states corresponding to m_cps
  std::vector<SymStore> m_states;
  /// edge-trace corresponding to m_cps
  SmallVector<const CpEdge *, 8> m_edges;
  // cutpoint graph for m_fn
  const CutPointGraph *m_cpg;
  // the function
  const llvm::Function *m_fn;
  // live symbols 
  std::unique_ptr<LiveSymbols> m_ls;  
  // solver used for the boolean abstraction
  ZSolver<EZ3> m_smt_solver;
  // used to solve a path formula
  ZSolver<EZ3> m_aux_smt_solver;  
  // symbolic store
  SymStore m_ctxState;
  /// precise encoding of m_cps
  ExprVector m_precise_side;
  /// last result
  boost::tribool m_result;  

  // TOREMOVE
  // Incomplete flag: if a SMT query returned unknown
  bool m_incomplete;

  // TOREMOVE  
  // Queue for unsolved path formulas
  std::queue<std::pair<unsigned, ExprVector>> m_unknown_path_formulas;
  
  // Count number of path
  unsigned m_num_paths;
  
  // TORENAME (path conditions) Boolean literals that active the
  // implicant: used to produce blocking clauses for the Boolean
  // abstraction.
  ExprVector m_active_bool_lits;

  // TOREMOVE
  // model of a path formula
  ZModel<EZ3> m_model;

  //// Crab stuff
  // Stuff used by crab's (sea-dsa) heap abstraction.
  const llvm::DataLayout &m_dl;
  const llvm::TargetLibraryInfo &m_tli;
  llvm::CallGraph &m_cg;
  sea_dsa::AllocWrapInfo &m_awi;
  // crab's heap abstraction 
  std::unique_ptr<clam::HeapAbstraction> m_mem;
  // crab instance to solve paths
  std::unique_ptr<clam::IntraClam> m_crab_path;
  
  // Temporary sanity check: bookeeping of all generated blocking clauses.
  std::unordered_set<Expr> m_blocking_clauses;

  // Check feasibility of a path induced by model using SMT solver.
  // Return true (sat), false (unsat), or indeterminate (inconclusive).
  // If unsat then it produces a blocking clause.
  typedef DenseMap<const BasicBlock *, ExprVector> invariants_map_t;
  boost::tribool
  path_encoding_and_solve_with_smt(const PathBmcTrace &trace,
                                   const invariants_map_t &invariants,
                                   const invariants_map_t &path_constraints);

  // Return false if a blocking clause has been generated twice.
  bool add_blocking_clauses();

  // For debugging
  void toSmtLib(const ExprVector &path, std::string prefix = "");
  
  // Check feasibility of a path induced by trace using abstract
  // interpretation.
  // Return true (sat) or false (unsat). If unsat then it produces a
  // blocking clause.
  bool path_encoding_and_solve_with_ai(PathBmcTrace &trace,
                                       invariants_map_t &path_constraints);
  
  /// Out contains all invariants (per block) inferred by crab.
  void load_invariants(const clam::IntraClam& analysis,
                       DenseMap<const BasicBlock *, ExprVector> &out);

  /// Add the crab invariants in m_side after applying the symbolic store s.
  void assert_invariants(const invariants_map_t &invariants, SymStore &s);

};

// Copy-and-paste version of BmcTrace in Bmc.hh
class PathBmcTrace {
  
  PathBmcEngine &m_bmc;
  
  ZModel<EZ3> m_model;
  
  // for trace specific implicant
  ExprVector m_trace;
  
  ExprMap m_bool_map;

  /// the trace of basic blocks
  SmallVector<const BasicBlock *, 8> m_bbs;

  /// a map from an index of a basic block on a trace to the index
  /// of the corresponding cutpoint in BmcEngine
  SmallVector<unsigned, 8> m_cpId;

  /// cutpoint id corresponding to the given location
  unsigned cpid(unsigned loc) const { return m_cpId[loc]; }

  /// true if loc is the first location on a cutpoint edge
  bool isFirstOnEdge(unsigned loc) const {
    return loc == 0 || cpid(loc - 1) != cpid(loc);
  }

public:
  PathBmcTrace(PathBmcEngine &bmc, ZModel<EZ3> &model);

  PathBmcTrace(const PathBmcTrace &other)
      : m_bmc(other.m_bmc), m_model(other.m_model), m_bbs(other.m_bbs),
        m_cpId(other.m_cpId) {}

  /// underlying BMC engine
  PathBmcEngine &engine() { return m_bmc; }
  
  /// The number of basic blocks in the trace
  unsigned size() const { return m_bbs.size(); }

  /// The basic block at a given location
  const llvm::BasicBlock *bb(unsigned loc) const { return m_bbs[loc]; }

  /// The value of the instruction at the given location
  Expr symb(unsigned loc, const llvm::Value &inst);
  Expr eval(unsigned loc, const llvm::Value &inst, bool complete = false);
  Expr eval(unsigned loc, Expr v, bool complete = false);
  
  void print(llvm::raw_ostream &o);

  ExprVector &get_implicant_formula() { return m_trace; }
  const ExprVector &get_implicant_formula() const { return m_trace; }
  
  ExprMap &get_implicant_bools_map() { return m_bool_map; }
  const ExprMap &get_implicant_bools_map() const { return m_bool_map; }
};

} // namespace seahorn
#endif 
